<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>XPDTN Season 4 Survey Results - Live Dashboard</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;line-height:1.6;color:#fff;background:#1a1a1a}
.loading{padding:40px;text-align:center;color:#9ca3af;font-size:1.1em}
.error{background:#3d1a1a;color:#ff6b6b;padding:20px;margin:20px;border-radius:10px;border:1px solid #5a2a2a}
.container{max-width:100%;margin:0;background:#1a1a1a;padding:0 16px}
.content{padding:5px 0 15px 0;background:#1a1a1a;max-width:100%}
.section{margin-bottom:25px}
.survey-question{background:#2a2a2a;border-radius:16px;padding:18px;border:1px solid #3a3a3a;box-shadow:0 3px 8px rgba(0,0,0,.3);animation:slideIn .5s ease-out}
@keyframes slideIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
.section-title{font-size:1.3em;margin-bottom:8px;color:#fff;font-weight:600;line-height:1.3}
.response-count{color:#9ca3af;font-size:.9em;margin-bottom:15px}
.responses-container{background:#1a1a1a;border-radius:12px;padding:0 0 4px 0;border:1px solid #3a3a3a}
.response-item{display:flex;align-items:center;padding:16px 18px;margin-bottom:4px;border-radius:6px;position:relative;background:#1a1a1a;animation:fadeInBar .8s ease-out}
@keyframes fadeInBar{from{opacity:0;transform:translateX(-20px)}to{opacity:1;transform:translateX(0)}}
.response-item:last-child{margin-bottom:0}
.response-content{flex:1;margin-right:15px;z-index:2;position:relative}
.response-text{color:#fff;font-weight:600;margin-bottom:0;font-size:1.1em;line-height:1.3}
.response-bar{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;border-radius:6px}
.response-bar-fill{height:100%;background:linear-gradient(90deg,#625166,#4a3d52);transition:width 1.2s ease-in-out;opacity:.8;border-radius:6px;width:0%}
.response-stats{text-align:right;flex-shrink:0;min-width:75px;z-index:2;position:relative}
.response-percentage{color:#625166;font-weight:700;font-size:1.2em}
.response-number{color:#9ca3af;font-size:.85em;margin-top:1px}
.other-responses{background:#1a1a1a;border-radius:12px;padding:15px;border:1px solid #3a3a3a;margin-top:12px}
.other-title{color:#625166;font-weight:600;margin-bottom:6px;font-size:1em}
.other-text{color:#d1d5db;line-height:1.5;font-size:.9em}
.update-time{text-align:center;color:#6b7280;font-size:.75em;margin-top:15px;margin-bottom:20px;padding:8px}
@media (max-width:480px){
  .container{padding:0 12px}
  .content{padding:3px 0 12px 0}
  .section-title{font-size:1.2em}
  .response-text{font-size:1em}
  .response-percentage{font-size:1.1em}
  .response-item{padding:14px 16px}
  .response-content{margin-right:12px}
  .response-stats{min-width:65px}
}
</style>
</head>
<body>
  <div id="dashboard-content">
    <div class="loading">Loading survey data…</div>
  </div>

<script>
/* =========================
   CONFIG / BOOT
   ========================= */
const API_URL = '/api/survey-data'; // same origin as your Pages site

document.addEventListener('DOMContentLoaded', () => {
  loadAndRender().catch(err => showDashboardError(err.message || String(err)));
});

async function loadAndRender() {
  const res = await fetch(API_URL, { credentials: 'omit' });
  if (!res.ok) throw new Error(`API error: ${res.status} ${res.statusText}`);
  const raw = await res.json();

  // 1) normalize API → generic question objects
  const normalized = adaptToRendererShape(raw);

  // 2) apply the custom display rules you had before
  const finalData = applyDisplayRules(normalized);

  // 3) render
  renderSurveyDashboard(finalData);
}

/* =========================
   ADAPTER (ignores meta)
   ========================= */
function adaptToRendererShape(raw) {
  const isArray = Array.isArray(raw);
  const hasQ = obj => obj && (obj.question || obj.title || obj.prompt || obj.header);

  // Already question array
  if (isArray && raw.every(q => hasQ(q) && Array.isArray(q.responses))) {
    return sanitizeQuestions(raw.map(minifyQuestion));
  }

  // Wrapped arrays
  if (!isArray && raw) {
    const maybe = raw.questions || raw.results || raw.items || raw.data || raw.survey || raw.payload || raw.sections;
    if (Array.isArray(maybe) && maybe.every(q => hasQ(q))) {
      return sanitizeQuestions(maybe.map(minifyQuestion));
    }
  }

  // Dictionary keyed by question text (skip meta keys)
  if (!isArray && raw && typeof raw === 'object') {
    const skipKeys = new Set(['sheet_info','sheetInfo','headers','meta','schema','stats','status','info','_info','_meta','_headers']);
    const entries = Object.entries(raw)
      .filter(([k,v]) => !skipKeys.has(k) && (Array.isArray(v) || (v && typeof v === 'object')));
    if (entries.length) {
      const qs = entries.map(([key, val]) => {
        const responses = toResponsesArray(val);
        return { question: key, total_responses: sumCounts(responses), responses };
      });
      return sanitizeQuestions(qs.map(minifyQuestion));
    }
  }

  // Single question object
  if (hasQ(raw) && Array.isArray(raw.responses)) {
    return sanitizeQuestions([minifyQuestion(raw)]);
  }

  // Flat array of options
  if (isArray && raw.length && looksLikeFlatOptions(raw)) {
    return sanitizeQuestions([{
      question: 'Survey Results',
      total_responses: sumCounts(raw),
      responses: raw.map(toResp)
    }]);
  }

  throw new Error('Unrecognized API response shape. Confirm JSON keys.');
}

/* ---------- adapter helpers ---------- */
function minifyQuestion(q) {
  const question = q.question || q.title || q.prompt || q.header || 'Untitled question';
  const other = q.other_responses || q.other || q.otherResponses || q.otherText || '';

  let responses = [];
  if (Array.isArray(q.responses)) responses = q.responses.map(toResp);
  else if (q.options) responses = toResponsesArray(q.options);
  else if (q.choices) responses = toResponsesArray(q.choices);
  else if (q.answers) responses = toResponsesArray(q.answers);

  const total = Number.isFinite(q.total_responses) ? q.total_responses : sumCounts(responses);

  responses = responses
    .map(r => ({
      text: (r.text ?? '').toString().trim(),
      count: Number(r.count || 0),
      percentage: typeof r.percentage === 'number'
        ? Math.round(r.percentage)
        : (total > 0 ? Math.round((Number(r.count || 0) / total) * 100) : 0)
    }))
    .filter(r => r.text && r.text.toLowerCase() !== 'option'); // drop placeholders

  // numeric scales in order; otherwise by count desc
  responses.sort((a,b) => {
    const na = Number(a.text), nb = Number(b.text);
    return (!Number.isNaN(na) && !Number.isNaN(nb)) ? na - nb : (b.count - a.count);
  });

  return {
    question,
    total_responses: total,
    responses,
    other_responses: other || undefined
  };
}

function sanitizeQuestions(qs) {
  return qs
    .filter(q => (q.responses || []).some(r => Number(r.count) > 0 && r.text))
    .map(q => ({
      ...q,
      total_responses: (q.responses || []).reduce((s,r)=>s + Number(r.count || 0), 0)
    }))
    .filter(q => q.total_responses > 0);
}

function toResponsesArray(x) {
  if (Array.isArray(x)) return x.map(toResp);
  if (x && typeof x === 'object') {
    return Object.entries(x).map(([k,v]) => toResp({ text: k, count: v }));
  }
  return [];
}

function toResp(item) {
  if (typeof item === 'string') return { text: item, count: 1 };
  if (typeof item === 'number') return { text: String(item), count: item };
  if (item && typeof item === 'object') {
    const text = item.text ?? item.label ?? item.option ?? item.name ?? item.title ?? '';
    const count = item.count ?? item.value ?? item.total ?? item.n ?? 0;
    const percentage = item.percentage ?? item.percent ?? item.pct;
    return { text: String(text ?? ''), count: Number(count || 0), percentage: percentage != null ? Number(percentage) : undefined };
  }
  return { text: '', count: 0 };
}

function looksLikeFlatOptions(arr) {
  return arr.every(v =>
    typeof v === 'string' ||
    typeof v === 'number' ||
    (v && typeof v === 'object' && ('text' in v || 'label' in v || 'option' in v || 'name' in v || 'title' in v))
  );
}

function sumCounts(list) {
  return list.reduce((s, r) => s + Number(r.count || 0), 0);
}

/* =========================
   YOUR QUESTION-SPECIFIC RULES
   ========================= */
function applyDisplayRules(questions) {
  return questions.map(q => {
    const title = (q.question || '').toLowerCase();

    // A) Go-to AI tool: normalize names + group <20% into "Other"
    if (title.includes("go-to ai tool") || title.includes("go to ai tool")) {
      return formatGoToTool(q);
    }

    // B) Confidence / 1–5 scale: force numeric order (already mostly sorted, but ensure)
    if (title.includes('confident') || title.includes('confidence') || title.includes('1-5') || title.includes('1 – 5') || title.includes('1 to 5')) {
      const copy = {...q};
      copy.responses = (q.responses||[]).slice().sort((a,b) => Number(a.text)-Number(b.text));
      return copy;
    }

    // C) Multi-select areas: snap to canonical sets; collect unmatched into Other responses
    if (
      title.includes("which areas of ai") ||
      title.includes("curious") ||
      title.includes("which areas of creator marketing") ||
      title.includes("testing ai tools for") ||
      title.includes("which of the following best describes") ||
      title.includes("select all that apply")
    ) {
      return snapToCanonicalOptions(q, pickCanonicalSet(title));
    }

    return q;
  });
}

// Canonical sets (edit if you change wording)
const CANONICAL = {
  aiUsage: [
    "Discovering or researching creators",
    "Drafting or reviewing creative briefs",
    "Writing emails, captions, or campaign copy",
    "Analyzing campaign results",
    "Generating images or video",
    "I'm not using AI at work yet"
  ],
  aiCuriosity: [
    "AI for creator discovery",
    "AI for campaign planning & briefing",
    "AI for reviewing creator content",
    "AI-generated content (video, images, voice)",
    "AI assistants & internal tooling",
    "Ethical implications / disclosure guidelines",
    "AI and brand safety",
    "How creators themselves are using AI",
    "AI and the future of creator platforms"
  ],
  creatorAreas: [
    "Creator Discovery & Vetting",
    "Brief Generation & Campaign Planning",
    "Outreach & Communication",
    "Content Review & Brand Safety",
    "Payment, Contracting & Legal Automation",
    "Performance Analysis & Reporting",
    "Competitor Monitoring & Trend Tracking",
    "Creative Co-Pilots for UGC",
    "Marketplace Optimization (e.g. TikTok Shop, Amazon Influencer)",
    "Internal Knowledge Systems & Institutional Memory"
  ]
};

function pickCanonicalSet(title) {
  if (title.includes('creator marketing')) return CANONICAL.creatorAreas;
  if (title.includes('curious')) return CANONICAL.aiCuriosity;
  // default for “which of the following best describes / select all”
  return CANONICAL.aiUsage;
}

function snapToCanonicalOptions(q, canonicalList) {
  const tally = Object.create(null);
  canonicalList.forEach(opt => { tally[opt] = 0; });

  const unmatched = [];
  (q.responses||[]).forEach(r => {
    const label = (r.text||'').trim();
    if (!label) return;
    const match = canonicalList.find(opt => opt.toLowerCase() === label.toLowerCase());
    if (match) {
      tally[match] += Number(r.count||0);
    } else {
      unmatched.push(label);
    }
  });

  const rows = Object.entries(tally)
    .map(([text,count]) => ({ text, count: Number(count||0) }))
    .filter(r => r.count > 0)
    .sort((a,b)=>b.count-a.count);

  const total = rows.reduce((s,r)=>s+r.count,0);
  const responses = rows.map(r => ({
    ...r,
    percentage: total>0 ? Math.round((r.count/total)*100) : 0
  }));

  return {
    ...q,
    responses,
    total_responses: total,
    other_responses: unmatched.length ? unmatched.join(', ') : undefined
  };
}

// Tool-name normalization for “go-to AI tool”
function normalizeToolName(s) {
  const t = String(s||'').trim().toLowerCase();
  if (!t) return '';
  if (t === 'gpt' || t.includes('chat gpt') || t.includes('chatgpt') || t.includes('openai')) return 'ChatGPT';
  if (t.includes('claude')) return 'Claude';
  if (t.includes('gemini') || t.includes('bard')) return 'Gemini';
  if (t.includes('gamma')) return 'Gamma';
  return capitalizeFirst(s);
}

function formatGoToTool(q) {
  const merged = {};
  (q.responses||[]).forEach(r => {
    const key = normalizeToolName(r.text);
    if (!key) return;
    merged[key] = (merged[key] || 0) + (Number(r.count)||0);
  });

  const total = Object.values(merged).reduce((s,n)=>s+Number(n||0),0);
  let rows = Object.entries(merged).map(([text,count]) => ({
    text, count, percentage: total>0 ? Math.round((count/total)*100) : 0
  })).sort((a,b)=>b.count-a.count);

  const popular = rows.filter(r => r.percentage >= 20);
  const small   = rows.filter(r => r.percentage < 20);
  if (small.length) {
    const otherCount = small.reduce((s,r)=>s+r.count,0);
    popular.push({
      text: 'Other',
      count: otherCount,
      percentage: total>0 ? Math.round((otherCount/total)*100) : 0
    });
  }

  return {
    ...q,
    responses: popular,
    total_responses: total,
    other_responses: small.length ? small.map(r=>r.text).join(', ') : undefined
  };
}

function capitalizeFirst(s){const str=String(s||'');return str?str[0].toUpperCase()+str.slice(1):''}

/* =========================
   RENDERER (pretty UI)
   ========================= */
function renderSurveyDashboard(data) {
  if (!Array.isArray(data) || data.length === 0) {
    return showDashboardError('No survey data to display.');
  }

  let html = '<div class="container"><div class="content">';
  data.forEach(q => {
    html += `
      <div class="section">
        <div class="survey-question">
          <h2 class="section-title">${escapeHTML(q.question)}</h2>
          <div class="response-count">${q.total_responses} responses</div>
          <div class="responses-container">
            ${q.responses.map(r => `
              <div class="response-item">
                <div class="response-bar">
                  <div class="response-bar-fill" style="width:${r.percentage}%"></div>
                </div>
                <div class="response-content">
                  <div class="response-text">${escapeHTML(r.text)}</div>
                </div>
                <div class="response-stats">
                  <div class="response-percentage">${r.percentage}%</div>
                  <div class="response-number">${r.count} response${r.count===1?'':'s'}</div>
                </div>
              </div>
            `).join('')}
          </div>
          ${q.other_responses ? `
            <div class="other-responses">
              <div class="other-title">Other responses:</div>
              <div class="other-text">${escapeHTML(q.other_responses)}</div>
            </div>` : ''
          }
        </div>
      </div>
    `;
  });
  html += `
    <div class="update-time">Last updated: ${new Date().toLocaleString()}</div>
  </div></div>`;

  const mount = document.getElementById('dashboard-content');
  mount.innerHTML = html;

  // Animate bars (stagger)
  setTimeout(() => {
    document.querySelectorAll('.response-bar-fill').forEach((bar, i) => {
      const target = bar.style.width;
      bar.style.width = '0%';
      setTimeout(() => { bar.style.width = target; }, 100 + i*50);
    });
  }, 100);
}

function showDashboardError(message) {
  const mount = document.getElementById('dashboard-content');
  mount.innerHTML = `
    <div class="error">
      <h3>Error</h3>
      <p>${escapeHTML(message)}</p>
      <p style="margin-top:8px;color:#d1d5db">Tip: open <code style="color:#ffb4b4">/api/survey-data</code> in a new tab to verify the JSON.</p>
    </div>
  `;
}

function escapeHTML(str) {
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#039;');
}
</script>
</body>
</html>
